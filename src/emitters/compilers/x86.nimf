#? strip | stdtmpl(emit = "stdout.write")
#
# type X86 = ref object of Emitter
# method writeHeader(self: X86) =
  .intel_syntax noprefix

  .data
  cells:
    .space 30000

  .text
  .global _start
  _start:
    ## store the pointer to cells in esi register
    mov esi, offset cells
# end method
#
# method writeInstruction(self: X86, instr: Instruction, i: var int) =
# case instr.command:
  # of MoveRight:
    ## move the pointer instr.n cells to the right
    add esi, ${instr.n}
  # of MoveLeft:
    ## move the pointer instr.n cells to the left
    sub esi, ${instr.n}
  # of Add:
	  addb [esi], ${instr.n}
  # of Sub:
    subb [esi], ${instr.n}
  # of Write:
    ## put sys_write() (at index 1) in function register
	  mov ax, 1
    ## first arg is the stdout (file descriptor 1)
    mov di, 1
    ## second arg is the cell pointer, but it is already stored in the right arg register
    ## third arg is the cell size
	  mov dx, 1
    # for n in 1..instr.n:
      ## make the call
      syscall
    # end for
  # of Read:
    ## put sys_read() (at index 0) in function register
    mov ax, 0
    ## first arg is the stdin (file descriptor 0)
	  mov di, 0
	  mov dx, 1
    # for n in 1..instr.n:
      syscall
    # end for
  # of LoopStart:
    ## custom label to indicate the start of a loop
    loop_${i}:
      ## if value at esi == 0, jump to the label corresponding to the end of the loop
      cmpb [esi], 0
      je loop_${instr.i}
  # of LoopEnd:
    loop_${i}:
      ## if value at esi != 0, jump to the label corresponding to the start of the loop
      cmpb [esi], 0
      jne loop_${instr.i}
# end case
# end method
#
# method writeFooter(self: X86) =
  ## put sys_exit() (at index 60) in ax register
	mov ax, 60
  ## first arg is the exit code
  mov di, 0
	syscall
# end method
