#? strip | stdtmpl(emit = "stdout.write")
#
# type X86 = ref object of Target
# method header(this: X86) =
    .intel_syntax noprefix

    .data
    cells:
        .space 30000

    .text
    .globl _start
    _start:
        ## store the pointer to cells in x9 register
        mov esi, offset cells
# end method
#
# method emit(this: X86, instr: Instruction, i: var int) =
# case instr.command:
    # of MoveRight:
        ## move the pointer instr.times cells to the right
        add esi, ${instr.times}
    # of MoveLeft:
        ## move the pointer instr.times cells to the left
        sub esi, ${instr.times}
    # of Add:
	    addb [esi], ${instr.times}
    # of Sub:
        subb [esi], ${instr.times}
    # of Write:
        ## put sys_write() (at index 1) in function register
	    mov ax, 1
        ## first arg is the stdout (file descriptor 1)
        mov di, 1
        ## second arg is the cell pointer, but it is already stored in the right arg register
        ## third arg is the cell size
	    mov dx, 1
        # for n in 1..instr.times:
            ## make the call
            syscall
        # end for
    # of Read:
        ## put sys_read() (at index 63) in function register
        mov ax, 0
        ## first arg is the stdin (file descriptor 0)
	    mov di, 0
	    mov dx, 1
        # for n in 1..instr.times:
            syscall
        # end for
    # of LoopStart:
        ## custom label to indicate the start of a loop
        loop_${i}:
            ## if value at esi == 0, jump to the label corresponding to the end of the loop
            cmpb [esi], 0
            je loop_${instr.index}
    # of LoopEnd:
        loop_${i}:
            ## if value at esi != 0, jump to the label corresponding to the start of the loop
            cmpb [esi], 0
            jne loop_${instr.index}
# end case
# end method

# method footer(this: X86) =
    ## put sys_exit() (at index 60) in ax register
	mov ax, 60
    ## first arg is the exit code
    mov di, 0
	syscall
# end method
